#!/usr/bin/env ruby

require 'getoptlong'

require 'rubygems'
require 'softlayer_api'

module SoftLayer
  class CredentialManager
    def self.delete_software_credentials(softlayer_client, software_password_ids, options = {})
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)

      if ! options[:yes_prompt]
        return false unless yes_prompt("You are deleting one or more software credentials, this cannot be undone, continue?")
      end

      software_password_service = softlayer_client[:Software_Component_Password]
      software_password_service.deleteObjects(software_password_ids.map { |sw_pw_id| { 'id' => sw_pw_id } })

      return true
    end

    def self.list_network_message_delivery_credentials(softlayer_client, options = {})
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)

      if (! options[:filter] || options[:filter].empty?) && (! options[:yes_prompt])
        return false unless yes_prompt("No filter options have been specified to narrow credential selection list, it may take a while to process, continue?")
      end

      account_service             = softlayer_client['SoftLayer_Account']
      net_msg_deliv_accts         = [ [ 'id', 'username', 'password', 'vendor' ] ]
      net_msg_deliv_object_filter = network_message_delivery_filters(options)

      account_service             = account_service.object_filter(net_msg_deliv_object_filter) unless net_msg_deliv_object_filter.empty?
      account_service             = account_service.object_mask(network_message_delivery_mask)
      net_msg_deliv_accts_details = account_service.getNetworkMessageDeliveryAccounts

      net_msg_deliv_accts_details.each do |net_msg_deliv_acct|
        net_msg_deliv_accts.push([ net_msg_deliv_acct['id'].to_s, net_msg_deliv_acct['username'], net_msg_deliv_acct['password'], net_msg_deliv_acct['vendor']['name'] ])
      end

      pretty_print_table(net_msg_deliv_accts)

      return true
    end

    def self.list_software_credential_details(softlayer_client, software_password_ids)
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)

      software_password_ids.each do |sw_pw_id|
        software_password_details = [ [ 'name', 'value' ] ]

        software_password_service = softlayer_client[:Software_Component_Password].object_with_id(sw_pw_id)
        software_password_service = software_password_service.object_mask(software_password_mask(:"list-details"))

        software_password         = software_password_service.getObject
        server_type               = software_password['software'].has_key?('hardware') ? 'hardware' : 'virtualGuest'
        required_user             = software_password['username'] == software_password['software']['softwareDescription']['requiredUser'] ? 'YES' : 'NO'

        software_password_details.push([ 'id',            software_password['id'].to_s ])
        software_password_details.push([ 'username',      software_password['username'] ])
        software_password_details.push([ 'password',      software_password['password'] ])
        software_password_details.push([ 'last modified', software_password['modifyDate'] ])
        software_password_details.push([ 'port',          software_password['port'] || "" ])
        software_password_details.push([ 'notes',         software_password['notes'] || "" ])
        software_password_details.push([ 'required user', required_user ])
        software_password_details.push([ 'description',   software_password['software']['softwareDescription']['longDescription'] ])
        software_password_details.push([ 'name',          software_password['software']['softwareDescription']['name'] ])
        software_password_details.push([ 'manufacturer',  software_password['software']['softwareDescription']['manufacturer'] ])
        software_password_details.push([ 'hostname',      software_password['software'][server_type]['hostname'] ])
        software_password_details.push([ 'domain',        software_password['software'][server_type]['domain'] ])
        software_password_details.push([ 'datacenter',    software_password['software'][server_type]['datacenter']['name'] ])
        software_password_details.push([ 'server type',   software_password['software'].has_key?('hardware') ? 'Hardware' : 'Virtual Guest' ])
        software_password_details.push([ 'tags',          software_password['software'][server_type]['tagReferences'].collect { |tag| tag['tag']['name'] }.join(", ") ])

        pretty_print_table(software_password_details)
        puts if software_password_ids.length > 1
      end
    end

    def self.list_software_credentials(softlayer_client, options = {})
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)

      if (! options[:filter] || options[:filter].empty?) && (! options[:yes_prompt])
        return false unless yes_prompt("No filter options have been specified to narrow credential selection list, it may take a while to process, continue?")
      end

      software_passwords = get_software_passwords(softlayer_client, options)

      software_passwords.map! { |sw_pw| [ sw_pw['id'].to_s, sw_pw['software']['softwareDescription']['name'], sw_pw.username, sw_pw.password ] }
      software_passwords.sort_by! { |element| element[1] }
      software_passwords.unshift([ "id", "software name", "username", "password" ])

      pretty_print_table(software_passwords)

      return true
    end

    def self.set_network_message_delivery_credentials(softlayer_client, password, options = {})
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)

      if (! options[:filter] || options[:filter].empty?) && (! options[:yes_prompt])
        return false unless yes_prompt("No filter options have been specified to narrow credential list to update, it may take a while to process, continue?")
      end

      if ! options[:yes_prompt]
        return false unless yes_prompt("You are setting one or more network message delivery credentials, this cannot be undone, continue?")
      end

      account_service             = softlayer_client['SoftLayer_Account']
      net_msg_deliv_object_filter = network_message_delivery_filters(options)

      account_service             = account_service.object_filter(net_msg_deliv_object_filter) unless net_msg_deliv_object_filter.empty?
      account_service             = account_service.object_mask(SoftLayer::NetworkMessageDelivery.default_object_mask)
      net_msg_deliv_accts         = account_service.getNetworkMessageDeliveryAccounts.collect{|net_msg_deliv_acct| SoftLayer::NetworkMessageDelivery.new(softlayer_client, net_msg_deliv_acct)}

      net_msg_deliv_accts.each{|net_msg_deliv_acct| net_msg_deliv_acct.password= password}

      return true
    end

    def self.set_software_credentials(softlayer_client, password, options = {})
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)

      if (! options[:filter] || options[:filter].empty?) && (! options[:yes_prompt])
        return false unless yes_prompt("No filter options have been specified to narrow credential list to update, it may take a while to process, continue?")
      end

      if ! options[:yes_prompt]
        return false unless yes_prompt("You are setting one or more software credentials, this cannot be undone, continue?")
      end

      software_passwords = get_software_passwords(softlayer_client, options)

      SoftLayer::SoftwarePassword.update_passwords(software_passwords, password, :client => softlayer_client)

      if options[:add_user_password]
        add_software_credentials(softlayer_client, password, options)
      end

      return true
    end

    private

    def self.add_software_credentials(softlayer_client, password, options = {})
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)
      raise "Expected a list of usernames to add software credentials for as part of filters" if ! options[:filter] || ! options[:filter][:username] || options[:filter][:username].empty?

      hardware_types                = [ :bare_metal_instance, :hardware, :network_hardware, :router ]

      add_hardware_passwords       = true
      add_virtual_server_passwords = true

      add_hardware_passwords       = false if options[:filter] && options[:filter][:virtual_servers_only]
      add_virtual_server_passwords = false if options[:filter] && options[:filter][:hardware_only]

      if add_hardware_passwords && (options[:filter][:hardware_type] && ! options[:filter][:hardware_type].empty?)
        hardware_types             = options[:filter][:hardware_type].map { |hardware_type| hardware_type.to_sym }
      end

      object_filters               = software_password_filters(:add, options)

      software                     = []

      if add_hardware_passwords
        hardware_types.each do |hardware_type|
          software_data = SoftLayer::Software.find_software_on_hardware(:client                 => softlayer_client,
                                                                        :hardware_object_filter => object_filters[:hardware][hardware_type],
                                                                        :software_object_filter => object_filters[:software],
                                                                        :software_object_mask   => software_mask)

          software.concat(software_data)
        end
      end

      if add_virtual_server_passwords
        software_data = SoftLayer::Software.find_software_on_virtual_servers(:client                       => softlayer_client,
                                                                             :software_object_filter       => object_filters[:software],
                                                                             :software_object_mask         => software_mask,
                                                                             :virtual_server_object_filter => object_filters[:virtual_server])

        software.concat(software_data)
      end

      software_passwords_template = software.map do |sw|
        options[:filter][:username].collect do |username|
          { 'softwareId' => sw['id'], 'password' => password.to_s, 'username' => username } if sw['passwords'] && ! sw['passwords'].map{ |pw| pw['username'] }.include?(username)
        end
      end

      software_password_service = softlayer_client[:Software_Component_Password]
      software_password_service.createObjects(software_passwords_template.flatten.compact)
    end

    def self.get_software_passwords(softlayer_client, options = {})
      raise "#{__method__} requires a SoftLayer client but none was given"   if !softlayer_client
      raise "Expected an instance of SoftLayer::Client for softlayer_client" unless softlayer_client.kind_of?(SoftLayer::Client)

      hardware_types                = [ :bare_metal_instance, :hardware, :network_hardware, :router ]

      list_hardware_passwords       = true
      list_virtual_server_passwords = true

      list_hardware_passwords       = false if options[:filter] && options[:filter][:virtual_servers_only]
      list_virtual_server_passwords = false if options[:filter] && options[:filter][:hardware_only]

      if list_hardware_passwords && (options[:filter][:hardware_type] && ! options[:filter][:hardware_type].empty?)
        hardware_types              = options[:filter][:hardware_type].map { |hardware_type| hardware_type.to_sym }
      end

      object_filters                = software_password_filters(:list, options)

      software_passwords            = []

      if list_hardware_passwords
        hardware_types.each do |hardware_type|
          passwords = SoftLayer::SoftwarePassword.find_passwords_for_software_on_hardware(:client                          => softlayer_client,
                                                                                          :hardware_object_filter          => object_filters[:hardware][hardware_type],
                                                                                          :software_object_filter          => object_filters[:software],
                                                                                          :software_password_object_filter => object_filters[:software_password],
                                                                                          :software_password_object_mask   => software_password_mask(:list))
          software_passwords.concat(passwords)
        end
      end

      if list_virtual_server_passwords
        passwords = SoftLayer::SoftwarePassword.find_passwords_for_software_on_virtual_servers(:client                          => softlayer_client,
                                                                                               :software_object_filter          => object_filters[:software],
                                                                                               :software_password_object_filter => object_filters[:software_password],
                                                                                               :software_password_object_mask   => software_password_mask(:list),
                                                                                               :virtual_server_object_filter    => object_filters[:virtual_server])
        software_passwords.concat(passwords)
      end

      return software_passwords
    end

    def self.pretty_print_table(table)
      max_col_widths = table.transpose.map { |col| col.group_by(&:size).max.first + 2 }
      print ':' + max_col_widths.map { |col_width| '.' * col_width}.join(':' ) + ":\n:"
      table[0].each_index {|col| print table[0][col].center(max_col_widths[col]) + ':' }
      print "\n:" + max_col_widths.map { |col_width| '.' * col_width }.join(':') + ":\n"
      table.shift
      table.each do |row|
        print ':'
        row.each_index { |col| print row[col].center(max_col_widths[col]) + ':' }
        puts
      end
      puts ':' + max_col_widths.map { |col_width| '.' * col_width }.join(':') + ':'
    end

    def self.network_message_delivery_mask()
      {
        "mask(SoftLayer_Network_Message_Delivery)" => [
                                                       'id',
                                                       'password',
                                                       'username',
                                                       'vendor.name'
                                                      ]
      }.to_sl_object_mask
    end

    def self.software_mask()
      {
        "mask(SoftLayer_Software_Component)" => [
                                                 'id',
                                                 'manufacturerActivationCode',
                                                 'manufacturerLicenseInstance',
                                                 'passwords.username'
                                                ]
      }.to_sl_object_mask
    end

    def self.network_message_delivery_filters(options = {})
      option_to_filter_path = {
        :username => 'networkMessageDeliveryAccounts.username',
        :vendor   => 'networkMessageDeliveryAccounts.vendor.name'
      }

      net_msg_deliv_object_filter = SoftLayer::ObjectFilter.new()

      if options[:filter]
        option_to_filter_path.each do |option, filter_path|
          if options[:filter][option] && ! options[:filter][option].empty?
            net_msg_deliv_object_filter.set_criteria_for_key_path(filter_path,
                                                                  {
                                                                    'operation' => 'in',
                                                                    'options' => [{
                                                                                    'name' => 'data',
                                                                                    'value' => options[:filter][option].collect{ |tag_value| tag_value.to_s }
                                                                                  }]
                                                                  })
          end
        end
      end

      return net_msg_deliv_object_filter
    end

    def self.software_password_filters(filter_type, options = {})
      filter_label = {
        :bare_metal_instance => "bareMetalInstances",
        :hardware            => "hardware",
        :network_hardware    => "networkHardware",
        :router              => "routers"
      }

      hardware_types                  = filter_label.keys

      list_hardware_passwords         = true
      list_virtual_server_passwords   = true

      hardware_object_filter          = {
        :bare_metal_instance          => SoftLayer::ObjectFilter.new(),
        :hardware                     => SoftLayer::ObjectFilter.new(),
        :network_hardware             => SoftLayer::ObjectFilter.new(),
        :router                       => SoftLayer::ObjectFilter.new()
      }
      software_object_filter          = SoftLayer::ObjectFilter.new()
      software_password_object_filter = SoftLayer::ObjectFilter.new()
      virtual_server_object_filter    = SoftLayer::ObjectFilter.new()

      option_to_filter_path = {
        :hardware          => {
          :datacenter      => lambda { |hardware_type| return [ filter_label[hardware_type], '.datacenter.name' ].join        },
          :domain          => lambda { |hardware_type| return [ filter_label[hardware_type], '.domain' ].join                 },
          :hostname        => lambda { |hardware_type| return [ filter_label[hardware_type], '.hostname' ].join               },
          :tag             => lambda { |hardware_type| return [ filter_label[hardware_type], '.tagReferences.tag.name' ].join }
        },
        :software          => {
          :description     => "softwareComponents.softwareDescription.longDescription",
          :manufacturer    => "softwareComponents.softwareDescription.manufacturer",
          :name            => "softwareComponents.softwareDescription.name",
          :username        => "softwareComponents.passwords.username"
        },
        :software_password => {
          :username        => "passwords.username"
        },
        :virtual_server    => {
          :datacenter      => "virtualGuests.datacenter.name",
          :domain          => "virtualGuests.domain",
          :hostname        => "virtualGuests.hostname",
          :tag             => "virtualGuests.tagReferences.tag.name"
        }
      }

      if options[:filter]
        list_hardware_passwords       = false if options[:filter][:virtual_servers_only]
        list_virtual_server_passwords = false if options[:filter][:hardware_only]

        option_to_filter_path[:software].each do |option, filter_path|
          if options[:filter][option] && ! options[:filter][option].empty?
            next if option == :username && filter_type == :add

            software_object_filter.set_criteria_for_key_path(filter_path,
                                                             {
                                                               'operation' => 'in',
                                                               'options' => [{
                                                                               'name' => 'data',
                                                                               'value' => options[:filter][option].collect{ |filter_value| filter_value.to_s }
                                                                             }]
                                                             })
          end
        end

        option_to_filter_path[:software_password].each do |option, filter_path|
          if options[:filter][option] && ! options[:filter][option].empty?
            software_password_object_filter.set_criteria_for_key_path(filter_path,
                                                                      {
                                                                        'operation' => 'in',
                                                                        'options' => [{
                                                                                        'name' => 'data',
                                                                                        'value' => options[:filter][option].collect{ |filter_value| filter_value.to_s }
                                                                                      }]
                                                                      })
          end
        end

        if list_hardware_passwords
          if options[:filter][:hardware_type] && ! options[:filter][:hardware_type].empty?
            hardware_types = options[:filter][:hardware_type].map { |hardware_type| hardware_type.to_sym }
          end

          hardware_types.each do |hardware_type|
            option_to_filter_path[:hardware].each do |option, filter_path|
              if options[:filter][option] && ! options[:filter][option].empty?
                hardware_object_filter[hardware_type].set_criteria_for_key_path(filter_path.call(hardware_type),
                                                                                {
                                                                                  'operation' => 'in',
                                                                                  'options' => [{
                                                                                                  'name' => 'data',
                                                                                                  'value' => options[:filter][option].collect{ |filter_value| filter_value.to_s }
                                                                                                }]
                                                                                })
              end
            end
          end
        end

        if list_virtual_server_passwords
          option_to_filter_path[:virtual_server].each do |option, filter_path|
            if options[:filter][option] && ! options[:filter][option].empty?
              virtual_server_object_filter.set_criteria_for_key_path(filter_path,
                                                                     {
                                                                       'operation' => 'in',
                                                                       'options' => [{
                                                                                       'name' => 'data',
                                                                                       'value' => options[:filter][option].collect{ |filter_value| filter_value.to_s }
                                                                                     }]
                                                                     })
            end
          end
        end
      end

      {
        :hardware          => hardware_object_filter,
        :software          => software_object_filter,
        :software_password => software_password_object_filter,
        :virtual_server    => virtual_server_object_filter
      }
    end

    def self.software_password_mask(mask_type)
      case mask_type
      when :list
        {
          "mask(SoftLayer_Software_Component_Password)" => [
                                                            'createDate',
                                                            'id',
                                                            'modifyDate',
                                                            'notes',
                                                            'password',
                                                            'port',
                                                            'software.softwareDescription.name',
                                                            'username'
                                                           ]
        }.to_sl_object_mask
      when :"list-details"
        {
          "mask(SoftLayer_Software_Component_Password)" => [
                                                            'id',
                                                            'modifyDate',
                                                            'notes',
                                                            'password',
                                                            'port',
                                                            'software.hardware[datacenter.name, domain, hostname, tagReferences.tag.name]',
                                                            'software.softwareDescription[longDescription, manufacturer, name, requiredUser]',
                                                            'software.virtualGuest[datacenter.name, domain, hostname, tagReferences.tag.name]',
                                                            'username'
                                                           ]
        }.to_sl_object_mask
      end
    end

    def self.yes_prompt(prompt_message)
      while true do
        $stderr.print prompt_message.to_s + " (Y/N): "

        case $stdin.readline().chomp!
        when 'yes', 'y', 'Y'
          return true
        when 'no', 'n', 'N'
          return false
        else
          next
        end
      end
    end
  end #CredentialManager
end

class VagrantSoftLayerCredentials
  def initialize()
    @cli_opts = [
                 [ '--add',             '-a', GetoptLong::NO_ARGUMENT       ],
                 [ '--datacenter',      '-d', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--description',           GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--domain',          '-D', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--hardware',              GetoptLong::NO_ARGUMENT       ],
                 [ '--hardware_type',         GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--hostname',        '-H', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--help',            '-h', GetoptLong::NO_ARGUMENT       ],
                 [ '--manufacturer',    '-m', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--name',            '-n', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--password',        '-p', GetoptLong::NO_ARGUMENT       ],
                 [ '--sl_api_key',      '-k', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--sl_endpoint_url', '-e', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--sl_timeout',      '-t', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--sl_username',     '-u', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--tag',             '-T', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--username',        '-U', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--vendor',          '-v', GetoptLong::REQUIRED_ARGUMENT ],
                 [ '--virtual_servers',       GetoptLong::NO_ARGUMENT       ],
                 [ '--yes',             '-y', GetoptLong::NO_ARGUMENT       ]
                ]
    @config   = {
      :action            => nil,
      :action_args       => [],
      :add_user_password => false,
      :category          => nil,
      :filters           => {},
      :help              => false,
      :password          => nil,
      :password_flag     => false,
      :sl_credentials    => {
        :api_key      => nil,
        :endpoint_url => SoftLayer::API_PUBLIC_ENDPOINT,
        :timeout      => 60,
        :user_agent   => "vagrant-softlayer",
        :username     => nil
      },
      :username          => [],
      :yes_prompt        => false
    }
    @help = {
      :network_message_delivery => {},
      :software                 => {}
    }

    @help[:std_opts] = <<-HELP_STD_OPTS
Standard Options:

--help|-h:
    Print this help.

--sl_username|-u <USERNAME>:
    Sets the SoftLayer account user name. If not specified, it is assumed SL_API_USERNAME 
    environment variable is set.

--sl_api_key|-k <SL_API_KEY>:
    Sets the SoftLayer API key. If not specified, it is assumed SL_API_KEY environment
    variable is set.

--sl_endpoint_url|-e <SL_API_BASE_URL>:
    Sets the SoftLayer endpoint URL. If not specified, it assumed SL_API_BASE_URL environment
    variable is set to API_PUBLIC_ENDPOINT or API_PRIVATE_ENDPOINT.
    Defaults to API_PUBLIC_ENDPOINT.
HELP_STD_OPTS

    @help[:help]     = <<-HELP_EOM
Usage: #{File.basename($0)} <category> <action> [<args>...] [<options>...]
       #{File.basename($0)} <category> <action> [-h | --help]
       #{File.basename($0)} [-h | --help ]

The following credential management categories and associated actions are available:

software:
  delete        Delete credential username/password(s) for installed software.
  list          List credential username/password(s) for installed software.
  list-details  List credential details for a specific username/password instance related to installed software.
  set           Set credential password for username(s) related to installed software.

#{@help[:std_opts]}
HELP_EOM

    @help[:network_message_delivery_filters] = <<-HELP_NMD_FILTERS
Network Message Delivery Filter Options:

--vendor|-v <VENDOR>,...:
    Include network message delivery credentials whose vendor matches this list of vendors.
HELP_NMD_FILTERS

    @help[:software_filters]             = <<-HELP_SW_FILTERS
Software Filter Options:

--datacenter|-d <DATACENTER>,...:
    Include software credentials from software on servers matching this list of datacenters.

--description <DESCRIPTION>,...:
    Include software credentials from software whose description matches this list of descriptions.

--domain|-D <DOMAIN>,...:
    Include software credentials from software on servers matching this list of domains.

--hardware:
    Include software credentials from software on hardware only (not virtual servers).

--hardware_type >HARDWARE_TYPE>,...:
    Include software credentials from software on hardware matching this list of hardware types.

--hostname|-H <HOSTNAME>,...:
    Include software credentials from software on servers matching this list of hostnames.

--manufacturer|-m <MANUFACTURER>,...:
    Include software credentials from software whose manufacturer matches this list of manufacturers.

--name|-n <NAME>,...:
    Include software credentials from software whose name matches this list of names.

--tag|-T <TAG>,...:
    Include software credentials from software on servers matching this list of tags.

--virtual_servers:
    Include software credentials from software on virtual servers only (not hardware).
HELP_SW_FILTERS

    @help[:network_message_delivery][:list] = <<-HELP_NMD_LIST
Usage: #{File.basename($0)} network_message_delivery list [options]

List Credential Options:

--username|-u <USERNAME>,...:
    List the network message delivery credential(s) for these username(s) only.

--yes|-y:
    Automatic yes to prompt(s).

#{@help[:network_message_delivery_filters]}
#{@help[:std_opts]}
HELP_NMD_LIST

 @help[:network_message_delivery][:set]    = <<-HELP_NMD_SET
Usage: #{File.basename($0)} network_message_delivery set [options] [<password>]

<password> - The password to set for credential(s) matching option filters.

Set Credential Options:

--password|-p:
    Prompt for password from STDIN instead of expecting password as an argument.
    If not specified, it is expected that password is provided as an argument to
    the action. If both the argument and this option are provided, the argument
    takes precedence and the password will not be read.

--username|-u <USERNAME>,...:
    Set the software credential password for these username(s) only. If not specified, the password
    will be set for all software credentials that match other filtering criteria regardless
    of username.

--yes|-y:
    Automatic yes to prompt(s).

#{@help[:network_message_delivery_filters]}
#{@help[:std_opts]}
HELP_NMD_SET

    @help[:software][:delete] = <<-HELP_SW_DELETE
Usage: #{File.basename($0)} software delete [options] <ID>...

<ID> - One or more software credential ID's to delete

Delete Credential Options: 

--yes|-y:
    Automatic yes to prompt(s).

#{@help[:std_opts]}
HELP_SW_DELETE

    @help[:software][:list]              = <<-HELP_SW_LIST
Usage: #{File.basename($0)} software list [options]

List Credential Options:

--username|-u <USERNAME>,...:
    List the software credential(s) for these username(s) only.

--yes|-y:
    Automatic yes to prompt(s).

#{@help[:software_filters]}
#{@help[:std_opts]}
HELP_SW_LIST

    @help[:software][:"list-details"]    = <<-HELP_SW_LIST_DETAILS
Usage: #{File.basename($0)} software list-details [options] <ID>...

<ID> - One or more software credential ID's to list details for

#{@help[:std_opts]}
HELP_SW_LIST_DETAILS

    @help[:software][:set]    = <<-HELP_SW_SET_PW
Usage: #{File.basename($0)} software set [options] [<password>]

<password> - The password to set for credential(s) matching option filters.

Set Credential Options:

--add|-a:
    Add the username specified to all software credential instances if not currently present.

--password|-p:
    Prompt for password from STDIN instead of expecting password as an argument.
    If not specified, it is expected that password is provided as an argument to
    the action. If both the argument and this option are provided, the argument
    takes precedence and the password will not be read.

--username|-u <USERNAME>,...:
    Set the software credential password for these username(s) only. If not specified, the password
    will be set for all software credentials that match other filtering criteria regardless
    of username.

--yes|-y:
    Automatic yes to prompt(s).

#{@help[:software_filters]}
#{@help[:std_opts]}
HELP_SW_SET_PW
  end

  def run()
    proc_cli_options
    proc_cli_args

    if @config[:help]
      if @config[:action] && @config[:category]
        puts @help[@config[:category]][@config[:action]]
        exit 1
      else
        puts @help[:help]
        exit 1
      end
    end

    softlayer_client = SoftLayer::Client.new(@config[:sl_credentials])

    case @config[:category]
    when :network_message_delivery
      case @config[:action]
      when :list
        list_filter            = @config[:filters]
        list_filter[:username] = @config[:username] unless @config[:username].empty?

        exit 0 unless SoftLayer::CredentialManager.list_network_message_delivery_credentials(softlayer_client,
                                                                                             :filter     => list_filter,
                                                                                             :yes_prompt => @config[:yes_prompt])

      when :set
        set_filter            = @config[:filters]
        set_filter[:username] = @config[:username] unless @config[:username].empty?

        exit 0 unless SoftLayer::CredentialManager.set_network_message_delivery_credentials(softlayer_client,
                                                                                            @config[:password],
                                                                                            :filter     => @config[:filters],
                                                                                            :yes_prompt => @config[:yes_prompt])

      end
    when :software
      case @config[:action]
      when :delete
        exit 0 unless SoftLayer::CredentialManager.delete_software_credentials(softlayer_client,
                                                                               @config[:action_args],
                                                                               :yes_prompt => @config[:yes_prompt])

      when :list
        list_filter            = @config[:filters]
        list_filter[:username] = @config[:username] unless @config[:username].empty?

        exit 0 unless SoftLayer::CredentialManager.list_software_credentials(softlayer_client,
                                                                             :filter     => list_filter,
                                                                             :yes_prompt => @config[:yes_prompt])

      when :"list-details"
        SoftLayerManager.list_software_credential_details(softlayer_client, @config[:action_args])

      when :set
        set_filter            = @config[:filters]
        set_filter[:username] = @config[:username] unless @config[:username].empty?

        exit 0 unless SoftLayer::CredentialManager.set_software_credentials(softlayer_client,
                                                                            @config[:password],
                                                                            :add_user_password => @config[:add_user_password],
                                                                            :filter            => @config[:filters],
                                                                            :yes_prompt        => @config[:yes_prompt])

      end
    end
  end

  private

  def password_prompt()
    $stderr.print "Enter credential password: "
    return $stdin.readline().chomp!
  end

  def proc_cli_args()
    if ARGV[0] == nil && ! @config[:help]
      $stderr.puts "ERROR: No credential category provided to perform action on"
      exit 2
    end

    case ARGV[0]
    when "network_message_delivery"
      @config[:category] = :network_message_delivery

      if ARGV[1] == nil
        $stderr.puts "ERROR: No action provided for credential category #{ARGV[0]}"
        exit 2
      end

      case ARGV[1]
      when "list", "set"
        @config[:action] = ARGV[1].to_sym

      else
        $stderr.puts "ERROR: Invalid action for credential category #{ARGV[0]}: #{ARGV[1]}"
        exit 2

      end

      case ARGV[1]
      when "set"
        if ARGV.length != 3 && ! @config[:password_flag]
          $stderr.puts "ERROR: network_message_delivery action set requires a password be supplied either as an argument or read from STDIN using --password or -p option"
          exit 2
        end
        
        if ARGV.length == 3
          @config[:password] = ARGV[2].to_s
        elsif @config[:password_flag]
          @config[:password] = password_prompt
        end
      else
        if ARGV.length >= 3
          $stderr.puts "ERROR: #{ARGV[0]} action #{ARGV[1]} does not accept any arguments"
          exit 2
        end

      end

    when "software"
      @config[:category] = :software

      if ARGV[1] == nil
        $stderr.puts "ERROR: No action provided for credential category #{ARGV[0]}"
        exit 2
      end

      case ARGV[1]
      when "delete", "list", "list-details", "set"
        @config[:action] = ARGV[1].to_sym

      else
        $stderr.puts "ERROR: Invalid action for credential category #{ARGV[0]}: #{ARGV[1]}"
        exit 2

      end

      case ARGV[1]
      when "delete", "list-details"
        if ARGV.length < 3
          $stderr.puts "ERROR: #{ARGV[0]} action #{ARGV[1]} requires one or more software credential ID"
          exit 2
        end
        @config[:action_args] = ARGV.slice(2, ARGV.length - 2)

      when "set"
        if ARGV.length != 3 && ! @config[:password_flag]
          $stderr.puts "ERROR: #{ARGV[0]} action set requires a password be supplied either as an argument or read from STDIN using --password or -p option"
          exit 2
        end
        
        if ARGV.length == 3
          @config[:password] = ARGV[2].to_s
        elsif @config[:password_flag]
          @config[:password] = password_prompt
        end
      else
        if ARGV.length >= 3
          $stderr.puts "ERROR: #{ARGV[0]} action #{ARGV[1]} does not accept any arguments"
          exit 2
        end

      end

    else
      unless @config[:help]
        $stderr.puts "ERROR: Invalid credential category provided to perform action on"
        exit 2
      end

    end
  end

  def proc_cli_options()
    begin
      opts       = GetoptLong.new(*@cli_opts)
      opts.quiet = true

      opts.each do |opt, optval|
        case opt
        when '--add'
          @config[:add_user_password] = true

        when '--datacenter', '--description', '--domain', '--hardware_type', '--hostname', '--manufacturer', '--name', '--tag', '--vendor'
          @config[:filters][opt.slice(2, opt.length - 2).to_sym] = optval.to_s.split(',').delete_if{|token| token.empty? || token.match("\s+")}

        when '--hardware'
          @config[:filters][:hardware_only] = true

        when '--help'
          @config[:help] = true

        when '--password'
          @config[:password_flag] = true

        when '--sl_api_key'
          @config[:sl_credentials][:api_key] = optval.to_s
          
        when '--sl_endpoint_url'
          if ! [ "API_PUBLIC_ENDPOINT", "API_PRIVATE_ENDPOINT" ].include?(optval.to_s.upcase)
            $stderr.puts "ERROR: Invalid endpoint_url value: " + optval.to_s.upcase
            exit 2
          end
          
          @config[:sl_credentials][:endpoint_url] = (optval.to_s.upcase == 'API_PUBLIC_ENDPOINT' ? SoftLayer::API_PUBLIC_ENDPOINT : SoftLayer::API_PRIVATE_ENDPOINT)

        when '--sl_timeoout'
          @config[:sl_credentials][:timeout] = optval.to_i

        when '--sl_username'
          @config[:sl_credentials][:username] = optval.to_s

        when '--username'
          @config[:username] = optval.to_s.split(',').delete_if{|token| token.empty? || token.match("\s+")}

        when '--virtual_servers'
          @config[:filters][:virtual_servers_only] = true

        when '--yes'
          @config[:yes_prompt] = true

        end
      end
    rescue GetoptLong::Error => e
      $stderr.puts "vagrant-softlayer-credentials failed to process cli options: #{ e.message }"
      exit 1
    end

    @config[:sl_credentials][:api_key]  = ENV["SL_API_KEY"]      if @config[:sl_credentials][:api_key].nil?  && ENV.include?("SL_API_KEY")
    @config[:sl_credentials][:username] = ENV["SL_API_USERNAME"] if @config[:sl_credentials][:username].nil? && ENV.include?("SL_API_USERNAME")
    
    if @config[:sl_credentials][:api_key].nil?
      $stderr.puts "ERROR: No SoftLayer API key specified"
      exit 2
    end

    if @config[:sl_credentials][:endpoint_url].nil? && ENV.include?("SL_API_BASE_URL")
      if ! [ 'API_PRIVATE_ENDPOINT', 'API_PUBLIC_ENDPOINT' ].include?(ENV["SL_API_BASE_URL"])
        $stderr.puts "ERROR: Invalid SoftLayer endpoint URL specified in environment variable SL_API_BASE_URL, expected one of #{ [ 'API_PRIVATE_ENDPOINT', 'API_PUBLIC_ENDPOINT' ].inspect }: #{ ENV["SL_API_BASE_URL"].inspect }"
        exit 2
      end

      @config[:sl_credentials][:endpoint_url] = (ENV["SL_API_BASE_URL"] == "API_PUBLIC_ENDPOINT" ? SoftLayer::API_PUBLIC_ENDPOINT : SoftLayer::API_PRIVATE_ENDPOINT)
    end
    
    if @config[:sl_credentials][:username].nil?
      $stderr.puts "ERROR: No SoftLayer username specified"
      exit 2
    end

    if @config[:filters][:hardware_only] && @config[:filters][:virtual_servers_only]
      $stderr.puts "ERROR: Option filters --hardware and --virtual_servers are mutually exclusive and cannot be used at the same time"
      exit 2
    end
  end
end

if __FILE__ == $0
  VagrantSoftLayerCredentials.new.run()
end
